{{- $repo := .Repo -}}

package {{.Package}}

// Code generated by repo-generator {{ .Version }}. DO NOT EDIT.

import (
    "context"
    "database/sql"
    {{ if has .Funcs "create" "update" "delete" }}
    "fmt"
    "strings"
    {{ end }}

    {{- range $i, $field := .Imports }}
    "{{ $field.Path }}"
    {{- end -}}
)

var (
    // Err{{ $repo.Model.Name }}Scan is the error that indicates a {{ $repo.Model.Name }} scan failed.
    Err{{ $repo.Model.Name }}Scan = errors.New("scan")
    // Err{{ $repo.Model.Name }}NotFound is the error that indicates a {{ $repo.Model.Name }} was not found.
    Err{{ $repo.Model.Name }}NotFound = errors.New("not found")
    // Err{{ $repo.Model.Name }}Exists is returned when the {{ $repo.Model.Name }} already exists.
    Err{{ $repo.Model.Name }}Exists = errors.New("exists")
    {{ if has .Funcs "update" }}
    // Err{{ $repo.Model.Name }}Update is the error that indicates a {{ $repo.Model.Name }} was not updated.
    Err{{ $repo.Model.Name }}Update = errors.New("update")
    {{- end -}}
)

// {{ $repo.Model.Name }}Row is an interface for anything that can scan a {{ $repo.Model.Name }}, copying the columns from the matched
// row into the values pointed at by dest.
type {{ $repo.Model.Name }}Row interface {
    Scan(dest ...any) error
}

// {{ $repo.Model.Name }}Repo is a repository for the {{ $repo.Model.Name }}.
type {{ $repo.Model.Name }}Repo struct {
    // db is the database connection.
    db    *sql.DB

    // table is the table name.
    table string

    {{ range $i, $field := $repo.ColKeysFields }}
        // col{{ $field.Name }} is the {{ $repo.Model.Name }}.{{ $field.Name }} column name. It can be used in a queries to specify the column.
        col{{ $field.Name }} string
    {{- end }}
    {{- range $i, $field := $repo.ColStatesFields }}
        // col{{ $field.Name }} is the {{ $repo.Model.Name }}.{{ $field.Name }} column name. It can be used in a queries to specify the column.
        col{{ $field.Name }} string
    {{- end -}}
}

// New{{ $repo.Model.Name }}Repo creates a new {{ $repo.Model.Name }}Repo.
func New{{ $repo.Model.Name }}Repo(db *sql.DB, table string) *{{ $repo.Model.Name }}Repo {
    return &{{ $repo.Model.Name }}Repo{
        db:    db,
        table: table,

        {{ range $i, $field := $repo.ColKeysFields }}
            col{{ $field.Name }}: "{{ $field.ColName }}",
        {{- end }}

        {{- range $i, $field := $repo.ColStatesFields }}
            col{{ $field.Name }}: "{{ $field.ColName }}",
        {{- end -}}
    }
}

// Scan scans a {{ $repo.Model.Name }} from the given {{ $repo.Model.Name }}Row (sql.Row|sql.Rows).
func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) Scan(_ context.Context, s {{ $repo.Model.Name }}Row) (*{{ $repo.Model.Name }}, error) {
    var (
        m {{ $repo.Model.Name }}
        {{- range $i, $field := $repo.ColKeysFields }}
            {{ fieldType $field }}
        {{- end }}
        {{- range $i, $field := $repo.ColStatesFields }}
            {{ fieldType $field }}
        {{- end -}}
    )

    err := s.Scan(
        {{- range $i, $field := $repo.ColKeysFields }}
            {{ scanField $field }},
        {{- end }}
        {{- range $i, $field := $repo.ColStatesFields }}
            {{ scanField $field }},
        {{- end }}
    )
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, Err{{ $repo.Model.Name }}NotFound
        }

        var pgErr *pgconn.PgError

        if errors.As(err, &pgErr) && pgErr.Code == pgerrcode.UniqueViolation{
            return nil, errors.WrapError(err, Err{{ $repo.Model.Name }}Exists)
        }

        return nil, errors.WrapError(err, Err{{ $repo.Model.Name }}Scan)
    }

    {{- range $i, $field := $repo.ColKeysFields }}
        {{ sqlToField $field }}
    {{- end }}
    {{- range $i, $field := $repo.ColStatesFields }}
        {{ sqlToField $field }}
    {{- end }}

    return &m, nil
}

// ScanAll scans a slice of {{ $repo.Model.Name }} from the given sql.Rows.
func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) ScanAll(ctx context.Context, rs *sql.Rows) ([]*{{ $repo.Model.Name }}, error) {
    var ms []*{{ $repo.Model.Name }}

    for rs.Next() {
        m, err := {{ $repo.Receiver }}.Scan(ctx, rs)
        if err != nil {
            return nil, err
        }

        ms = append(ms, m)
    }

    if len(ms) == 0 {
        return nil, Err{{ $repo.Model.Name }}NotFound
    }

    return ms, nil
}

{{ if has .Funcs "create" }}
// Create creates a new {{ $repo.Model.Name }} and returns {{ if $repo.Model.Auto -}} the persisted {{ $repo.Model.Name }}.
//
// The returned {{ $repo.Model.Name }} will contain the fields that were tag as "auto", which maybe were generated by the
// database.{{- else -}} it after persisting{{- end -}}.
func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) Create(ctx context.Context, m *{{ $repo.Model.Name }}) (*{{ $repo.Model.Name }}, error) {
    var (
        cols []string
        args []interface{}
    )

    {{- range $i, $field := $repo.ColKeysFields }}
        {{ fieldToCreateSql $field }}
    {{- end }}
    {{- range $i, $field := $repo.ColStatesFields }}
        {{ fieldToCreateSql $field }}
    {{- end }}

    values := make([]string, len(cols))

    for i := range cols {
        values[i] = fmt.Sprintf("$%d", i+1)
    }

    qCols := strings.Join(cols, ", ")
    qValues := strings.Join(values, ", ")

    {{ if $repo.Model.Auto }}
    rCols := strings.Join([]string{
    {{- range $i, $field := $repo.ColKeysFields }}
        {{ $repo.Receiver }}.col{{ $field.Name }},
    {{- end}}
    {{- range $i, $field := $repo.ColStatesFields }}
        {{ $repo.Receiver }}.col{{ $field.Name }},
    {{- end}}
    }, ", ")

    sql := "INSERT INTO %s (%s) VALUES (%s) RETURNING %s"
    sql = fmt.Sprintf(sql, {{ $repo.Receiver }}.table, qCols, qValues, rCols)

    return  {{ $repo.Receiver }}.Scan(ctx, {{ $repo.Receiver }}.db.QueryRowContext(ctx, sql, args...))
    {{ else }}
    sql := "INSERT INTO %s (%s) VALUES (%s)"
    sql = fmt.Sprintf(sql, {{ $repo.Receiver }}.table, qCols, qValues)

    _, err := {{ $repo.Receiver }}.db.ExecContext(ctx, sql, args...)
    if err != nil {
        return nil, errors.Wrap(err, "exec context")
    }

    return  m, nil
    {{ end -}}
}
{{ end }}

{{ if has .Funcs "insert" }}
// Insert inserts one or more {{ $repo.Model.Name }} records into the database.
//
// When using this method the {{ $repo.Model.Name }} fields that are tag as "auto" should be set as the other fields non tag as "auto".
// The same applies for those other fields that are tag as "omitempty".
func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) Insert(ctx context.Context, ms ...*{{ $repo.Model.Name }}) error {
    // Build values query.
    var (
        valuesQueryBuilder strings.Builder
        lms = len(ms)
    )

    var cols []string

    {{ range $i, $field := $repo.ColKeysFields }}
        cols = append(cols, {{ $repo.Receiver }}.col{{ $field.Name }})
    {{- end }}
    {{- range $i, $field := $repo.ColStatesFields }}
        cols = append(cols, {{ $repo.Receiver }}.col{{ $field.Name }})
    {{- end }}

    lcols := len(cols)

    // Size is equal to the number of models (lms) multiplied by the number of columns (lcols).
    args := make([]interface{}, 0, lms*lcols)

    for idx := range ms {
        m := ms[idx]

        indexOffset := idx * lcols

        valuesQueryBuilder.WriteString({{ $repo.Receiver }}.valuesStatement(cols, indexOffset, idx != lms-1))

        {{- range $i, $field := $repo.ColKeysFields }}
            {{ fieldToInsertSql $field }}
        {{- end }}
        {{- range $i, $field := $repo.ColStatesFields }}
            {{ fieldToInsertSql $field }}
        {{- end -}}
    }

    qCols := strings.Join(cols, ", ")

    sql := "INSERT INTO %s (%s) VALUES %s"
    sql = fmt.Sprintf(sql, repo.table, qCols, valuesQueryBuilder.String())

    _, err := {{ $repo.Receiver }}.db.ExecContext(ctx, sql, args...)
    if err != nil {
        var pgErr *pgconn.PgError

        if errors.As(err, &pgErr) && pgErr.Code == pgerrcode.UniqueViolation{
            return errors.WrapError(err, Err{{ $repo.Model.Name }}Exists)
        }

        return errors.Wrap(err, "exec context")
    }

    return  nil
}

// valuesStatement returns a string with the values statement ($n) for the given columns,
// starting from the given offset.
func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) valuesStatement(cols []string, offset int, separator bool) string {
    var sep string

    if separator {
        sep = ","
    }

    values := make([]string, len(cols))
    for i := range cols {
        values[i] = fmt.Sprintf("$%d", offset+(i+1))
    }

    return fmt.Sprintf("(%s)%s", strings.Join(values, ", "), sep)
}
{{ end }}

{{ if has .Funcs "update" }}
// Update updates a {{ $repo.Model.Name }}.
//
// skipZeroValues indicates whether to skip zero values from the update statement.
// In case of boolean fields, skipZeroValues is not applicable since false is the zero value of boolean and could be
// a potential update. Always set this type of fields.
//
// Returns the error Err{{ $repo.Model.Name }}Update if the {{ $repo.Model.Name }} was not updated and database did not error,
// otherwise database error.
func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) Update(ctx context.Context, m *{{ $repo.Model.Name }}, skipZeroValues bool) error {
    var (
        sets   []string
        where  []string
        args   []interface{}
        offset = 1
    )

    {{ range $i, $field := $repo.ColKeysFields }}
        where = append(where, fmt.Sprintf("%s = $%d", {{ $repo.Receiver }}.col{{ $field.Name }}, offset))
        args = append(args, m.{{ $field.Name }})

        offset++
    {{ end }}

    if skipZeroValues {
        {{- range $i, $field := $repo.ColStatesFields -}}
            {{ fieldToUpdateSql $field true }}
        {{ end -}}
    } else {
        {{- range $i, $field := $repo.ColStatesFields -}}
            {{ fieldToUpdateSql $field false }}
        {{ end -}}
    }

    qSets := strings.Join(sets, ", ")
    qWhere := strings.Join(where, " AND ")

    sql := "UPDATE %s SET %s WHERE %s"
    sql = fmt.Sprintf(sql, repo.table, qSets, qWhere)

    res, err := repo.db.ExecContext(ctx, sql, args...)
    if err != nil {
        return err
    }

    rowsAffected, err := res.RowsAffected()
    if err != nil {
        return err
    }

    if rowsAffected == 0 {
        return Err{{ $repo.Model.Name }}Update
    }

    return nil
}
{{ end }}


{{ if has .Funcs "delete" }}
// Delete deletes a {{ $repo.Model.Name }}.
//
// The {{ $repo.Model.Name }} must have the fields that are tag as "key" set.
func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) Delete(ctx context.Context, m *{{ $repo.Model.Name }}) error {
    var (
        where []string
        args  []interface{}
    )

    {{ range $i, $field := $repo.ColKeysFields }}
        where = append(where, fmt.Sprintf("%s = $%d", {{ $repo.Receiver }}.col{{ $field.Name }}, {{ inc $i }}))
        args = append(args, m.{{ $field.Name }})
    {{ end }}

    qWhere := strings.Join(where, " AND ")

    sql := "DELETE FROM %s WHERE %s"
    sql = fmt.Sprintf(sql, {{ $repo.Receiver }}.table, qWhere)

    _, err := {{ $repo.Receiver }}.db.ExecContext(ctx, sql, args...)
    if err != nil {
        return errors.Wrap(err, "exec context")
    }

    return nil
}
{{ end }}
