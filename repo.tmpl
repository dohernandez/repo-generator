package {{.Package}}

// Code generated by repo-generator. DO NOT EDIT.

import (
    "context"
    "database/sql"
    "fmt"
    "strings"

    {{- range $i, $field := .Imports }}
    "{{ $field.Path }}"
    {{- end }}
)

var (
    Err{{ .Repo.Model.Name }}Scan = errors.New("scan")
    Err{{ .Repo.Model.Name }}NotFound = errors.New("not found")
    Err{{ .Repo.Model.Name }}Update = errors.New("update")
)

type {{ .Repo.Model.Name }}Scanner interface {
    Scan(dest ...any) error
}

type {{ .Repo.Model.Name }}Repo struct {
    db    *sql.DB
    table string

    stateCols []string

    keyCols []string

    cols []string
}

func New{{ .Repo.Model.Name }}Repo(db *sql.DB, table string) *{{ .Repo.Model.Name }}Repo {
    keyCols := []string{
        {{- range $i, $field := .Repo.ColKeysFields }}
            "{{ $field.ColName }}",
        {{- end}}
    }

    stateCols := []string{
        {{- range $i, $field := .Repo.ColStatesFields }}
            "{{ $field.ColName }}",
        {{- end}}
    }

    cols := append(keyCols, stateCols...)

    return &{{ .Repo.Model.Name }}Repo{
        db:    db,
        table: table,

        keyCols: keyCols,
        stateCols: stateCols,
        cols: cols,
    }
}

func ({{ .Repo.Receiver }} *{{ .Repo.Model.Name }}Repo) Scan(_ context.Context, s {{ .Repo.Model.Name }}Scanner) (*{{ .Repo.Model.Name }}, error) {
    var (
        m {{ .Repo.Model.Name }}
        {{- range $i, $field := .Repo.ColKeysFields }}
            {{ $field | fieldType }}
        {{- end }}
        {{- range $i, $field := .Repo.ColStatesFields }}
            {{ $field | fieldType }}
        {{- end }}
    )

    err := s.Scan(
        {{- range $i, $field := .Repo.ColKeysFields }}
            {{ $field | scanField }},
        {{- end }}
        {{- range $i, $field := .Repo.ColStatesFields }}
            {{ $field | scanField }},
        {{- end }}
    )
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, Err{{ .Repo.Model.Name }}NotFound
        }

        return nil, errors.WrapError(err, Err{{ .Repo.Model.Name }}Scan)
    }

    {{- range $i, $field := .Repo.ColKeysFields }}
        {{ $field | sqlToField }}
    {{- end }}
    {{- range $i, $field := .Repo.ColStatesFields }}
        {{ $field | sqlToField }}
    {{- end }}

    return &m, nil
}

func ({{ .Repo.Receiver }} *{{ .Repo.Model.Name }}Repo) ScanAll(ctx context.Context, rs *sql.Rows) ([]*{{ .Repo.Model.Name }}, error) {
    var ms []*{{ .Repo.Model.Name }}

    for rs.Next() {
        m, err := {{ .Repo.Receiver }}.Scan(ctx, rs)
        if err != nil {
            return nil, err
        }

        ms = append(ms, m)
    }

    if len(ms) == 0 {
        return nil, Err{{ .Repo.Model.Name }}NotFound
    }

    return ms, nil
}

func ({{ .Repo.Receiver }} *{{ .Repo.Model.Name }}Repo) Create(ctx context.Context, m *{{ .Repo.Model.Name }}) (*{{ .Repo.Model.Name }}, error) {
    var (
        cols []string
        args []interface{}
    )

    {{- range $i, $field := .Repo.ColKeysFields }}
        {{ $field | fieldToCreateSql }}
    {{- end }}
    {{- range $i, $field := .Repo.ColStatesFields }}
        {{ $field | fieldToCreateSql }}
    {{- end }}

    values := make([]string, len(cols))

    for i := range cols {
        values[i] = fmt.Sprintf("$%d", i+1)
    }

    qCols := strings.Join(cols, ", ")
    qValues := strings.Join(values, ", ")

    {{if .Repo.Model.Auto}}
    rCols := strings.Join({{ .Repo.Receiver }}.cols, ", ")

    sql := "INSERT INTO %s (%s) VALUES (%s) RETURNING %s"
    sql = fmt.Sprintf(sql, {{ .Repo.Receiver }}.table, qCols, qValues, rCols)

    return  {{ .Repo.Receiver }}.Scan(ctx, {{ .Repo.Receiver }}.db.QueryRowContext(ctx, sql, args...))
}
    {{else}}
    sql := "INSERT INTO %s (%s) VALUES (%s)"
    sql = fmt.Sprintf(sql, {{ .Repo.Receiver }}.table, qCols, qValues)

    _, err := {{ .Repo.Receiver }}.db.ExecContext(ctx, sql, args...)
    if err != nil {
        return nil, errors.Wrap(err, "exec context")
    }

    return  m, nil
}
    {{end}}

func ({{ .Repo.Receiver }} *{{ .Repo.Model.Name }}Repo) Insert(ctx context.Context, ms ...*{{ .Repo.Model.Name }}) error {
    // Build values query.
    var (
        valuesQueryBuilder strings.Builder
        lms = len(ms)
    )

    var cols []string

    {{- range $i, $field := .Repo.ColKeysFields }}
        cols = append(cols, "{{ $field.ColName }}")
    {{- end }}
    {{- range $i, $field := .Repo.ColStatesFields }}
        cols = append(cols, "{{ $field.ColName }}")
    {{- end }}

    lcols := len(cols)

    // Size is equal to the number of models (lms) multiplied by the number of columns (lcols).
    args := make([]interface{}, 0, lms*lcols)

    for i := range ms {
        m := ms[i]

        indexOffset := i * lcols
        valuesQueryBuilder.WriteString({{ .Repo.Receiver }}.valuesStatement(cols, indexOffset, i != lms-1))


        {{- range $i, $field := .Repo.ColKeysFields }}
            {{ $field | fieldToInsertSql }}
        {{- end }}
        {{- range $i, $field := .Repo.ColStatesFields }}
            {{ $field | fieldToInsertSql }}
        {{- end }}
    }

    qCols := strings.Join(cols, ", ")

    sql := "INSERT INTO %s (%s) VALUES %s"
    sql = fmt.Sprintf(sql, repo.table, qCols, valuesQueryBuilder.String())

    _, err := {{ .Repo.Receiver }}.db.ExecContext(ctx, sql, args...)
    if err != nil {
        return errors.Wrap(err, "exec context")
    }

    return  nil
}

func ({{ .Repo.Receiver }} *{{ .Repo.Model.Name }}Repo) valuesStatement(cols []string, offset int, separator bool) string {
    var sep string

    if separator {
        sep = ","
    }

    values := make([]string, len(cols))
    for i := range cols {
        values[i] = fmt.Sprintf("$%d", offset+(i+1))
    }

    return fmt.Sprintf("(%s)%s", strings.Join(values, ", "), sep)
}

func ({{ .Repo.Receiver }} *{{ .Repo.Model.Name }}Repo) Update(ctx context.Context, m *{{ .Repo.Model.Name }}) error {
    var (
        sets   []string
        where  []string
        args   []interface{}
        offset = 1
    )

    {{- range $i, $field := .Repo.ColKeysFields }}
        where = append(where, fmt.Sprintf("{{ $field.ColName }} = $%d", offset))
        args = append(args, m.{{ $field.Name }})

        offset++
    {{- end }}

    {{- range $i, $field := .Repo.ColStatesFields }}
        {{ $field | fieldToUpdateSql }}
    {{- end }}

    qSets := strings.Join(sets, ", ")
    qWhere := strings.Join(where, " AND ")

    sql := "UPDATE %s SET %s WHERE %s"
    sql = fmt.Sprintf(sql, repo.table, qSets, qWhere)

    res, err := repo.db.ExecContext(ctx, sql, args...)
    if err != nil {
        return err
    }

    rowsAffected, err := res.RowsAffected()
    if err != nil {
        return err
    }

    if rowsAffected == 0 {
        return Err{{ .Repo.Model.Name }}Update
    }

    return nil
}
