{{- $repo := .Repo -}}

package {{.Package}}

// Code generated by repo-generator {{ .Version }}. DO NOT EDIT.

import (
    "context"
    "database/sql"
    "fmt"
    "strings"

    {{- range $i, $field := .Imports }}
    "{{ $field.Path }}"
    {{- end }}
)

var (
    Err{{ $repo.Model.Name }}Scan = errors.New("scan")
    Err{{ $repo.Model.Name }}NotFound = errors.New("not found")
    Err{{ $repo.Model.Name }}Update = errors.New("update")
)

type {{ $repo.Model.Name }}Scanner interface {
    Scan(dest ...any) error
}

type {{ $repo.Model.Name }}Repo struct {
    db    *sql.DB

    table string

    {{- range $i, $field := $repo.ColKeysFields }}
        col{{ $field.Name }} string
    {{- end}}
    {{- range $i, $field := $repo.ColStatesFields }}
        col{{ $field.Name }} string
    {{- end}}

    cols []string
}

func New{{ $repo.Model.Name }}Repo(db *sql.DB, table string) *{{ $repo.Model.Name }}Repo {
    cols := []string{
        {{- range $i, $field := $repo.ColKeysFields }}
            "{{ $field.ColName }}",
        {{- end}}
        {{- range $i, $field := $repo.ColStatesFields }}
            "{{ $field.ColName }}",
        {{- end}}
    }

    return &{{ $repo.Model.Name }}Repo{
        db:    db,
        table: table,

        {{- range $i, $field := $repo.ColKeysFields }}
            col{{ $field.Name }}: "{{ $field.ColName }}",
        {{- end}}

        {{- range $i, $field := $repo.ColStatesFields }}
            col{{ $field.Name }}: "{{ $field.ColName }}",
        {{- end}}

        cols: cols,
    }
}

func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) Scan(_ context.Context, s {{ $repo.Model.Name }}Scanner) (*{{ $repo.Model.Name }}, error) {
    var (
        m {{ $repo.Model.Name }}
        {{- range $i, $field := $repo.ColKeysFields }}
            {{ fieldType $field }}
        {{- end }}
        {{- range $i, $field := $repo.ColStatesFields }}
            {{ fieldType $field }}
        {{- end }}
    )

    err := s.Scan(
        {{- range $i, $field := $repo.ColKeysFields }}
            {{ scanField $field }},
        {{- end }}
        {{- range $i, $field := $repo.ColStatesFields }}
            {{ scanField $field }},
        {{- end }}
    )
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, Err{{ $repo.Model.Name }}NotFound
        }

        return nil, errors.WrapError(err, Err{{ $repo.Model.Name }}Scan)
    }

    {{- range $i, $field := $repo.ColKeysFields }}
        {{ sqlToField $field }}
    {{- end }}
    {{- range $i, $field := $repo.ColStatesFields }}
        {{ sqlToField $field }}
    {{- end }}

    return &m, nil
}

func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) ScanAll(ctx context.Context, rs *sql.Rows) ([]*{{ $repo.Model.Name }}, error) {
    var ms []*{{ $repo.Model.Name }}

    for rs.Next() {
        m, err := {{ $repo.Receiver }}.Scan(ctx, rs)
        if err != nil {
            return nil, err
        }

        ms = append(ms, m)
    }

    if len(ms) == 0 {
        return nil, Err{{ $repo.Model.Name }}NotFound
    }

    return ms, nil
}

func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) Create(ctx context.Context, m *{{ $repo.Model.Name }}) (*{{ $repo.Model.Name }}, error) {
    var (
        cols []string
        args []interface{}
    )

    {{- range $i, $field := $repo.ColKeysFields }}
        {{ fieldToCreateSql $field }}
    {{- end }}
    {{- range $i, $field := $repo.ColStatesFields }}
        {{ fieldToCreateSql $field }}
    {{- end }}

    values := make([]string, len(cols))

    for i := range cols {
        values[i] = fmt.Sprintf("$%d", i+1)
    }

    qCols := strings.Join(cols, ", ")
    qValues := strings.Join(values, ", ")

    {{if $repo.Model.Auto}}
    rCols := strings.Join({{ $repo.Receiver }}.cols, ", ")

    sql := "INSERT INTO %s (%s) VALUES (%s) RETURNING %s"
    sql = fmt.Sprintf(sql, {{ $repo.Receiver }}.table, qCols, qValues, rCols)

    return  {{ $repo.Receiver }}.Scan(ctx, {{ $repo.Receiver }}.db.QueryRowContext(ctx, sql, args...))
}
    {{else}}
    sql := "INSERT INTO %s (%s) VALUES (%s)"
    sql = fmt.Sprintf(sql, {{ $repo.Receiver }}.table, qCols, qValues)

    _, err := {{ $repo.Receiver }}.db.ExecContext(ctx, sql, args...)
    if err != nil {
        return nil, errors.Wrap(err, "exec context")
    }

    return  m, nil
}
    {{end}}

func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) Insert(ctx context.Context, ms ...*{{ $repo.Model.Name }}) error {
    // Build values query.
    var (
        valuesQueryBuilder strings.Builder
        lms = len(ms)
    )

    var cols []string

    {{- range $i, $field := $repo.ColKeysFields }}
        cols = append(cols, {{ $repo.Receiver }}.col{{ $field.Name }})
    {{- end }}
    {{- range $i, $field := $repo.ColStatesFields }}
        cols = append(cols, {{ $repo.Receiver }}.col{{ $field.Name }})
    {{- end }}

    lcols := len(cols)

    // Size is equal to the number of models (lms) multiplied by the number of columns (lcols).
    args := make([]interface{}, 0, lms*lcols)

    for i := range ms {
        m := ms[i]

        indexOffset := i * lcols

        valuesQueryBuilder.WriteString({{ $repo.Receiver }}.valuesStatement(cols, indexOffset, i != lms-1))

        {{- range $i, $field := $repo.ColKeysFields }}
            {{ fieldToInsertSql $field }}
        {{- end }}
        {{- range $i, $field := $repo.ColStatesFields }}
            {{ fieldToInsertSql $field }}
        {{- end }}
    }

    qCols := strings.Join(cols, ", ")

    sql := "INSERT INTO %s (%s) VALUES %s"
    sql = fmt.Sprintf(sql, repo.table, qCols, valuesQueryBuilder.String())

    _, err := {{ $repo.Receiver }}.db.ExecContext(ctx, sql, args...)
    if err != nil {
        return errors.Wrap(err, "exec context")
    }

    return  nil
}

func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) valuesStatement(cols []string, offset int, separator bool) string {
    var sep string

    if separator {
        sep = ","
    }

    values := make([]string, len(cols))
    for i := range cols {
        values[i] = fmt.Sprintf("$%d", offset+(i+1))
    }

    return fmt.Sprintf("(%s)%s", strings.Join(values, ", "), sep)
}

func ({{ $repo.Receiver }} *{{ $repo.Model.Name }}Repo) Update(ctx context.Context, m *{{ $repo.Model.Name }}, skipZeroValues bool) error {
    var (
        sets   []string
        where  []string
        args   []interface{}
        offset = 1
    )

    {{- range $i, $field := $repo.ColKeysFields }}

        where = append(where, fmt.Sprintf("%s = $%d", {{ $repo.Receiver }}.col{{ $field.Name }}, offset))
        args = append(args, m.{{ $field.Name }})

        offset++
    {{- end }}

    if skipZeroValues {
        {{- range $i, $field := $repo.ColStatesFields }}
            {{ fieldToUpdateSql $field }}
        {{- end }}
    } else {
        {{- range $i, $field := $repo.ColStatesFields }}

            where = append(where, fmt.Sprintf("%s = $%d", {{ $repo.Receiver }}.col{{ $field.Name }}, offset))
            args = append(args, m.{{ $field.Name }})

            offset++
        {{- end }}
    }

    qSets := strings.Join(sets, ", ")
    qWhere := strings.Join(where, " AND ")

    sql := "UPDATE %s SET %s WHERE %s"
    sql = fmt.Sprintf(sql, repo.table, qSets, qWhere)

    res, err := repo.db.ExecContext(ctx, sql, args...)
    if err != nil {
        return err
    }

    rowsAffected, err := res.RowsAffected()
    if err != nil {
        return err
    }

    if rowsAffected == 0 {
        return Err{{ $repo.Model.Name }}Update
    }

    return nil
}
