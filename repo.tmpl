package {{.Package}}

// Code generated by repo-generator. DO NOT EDIT.

import (
    "context"
    "database/sql"
    "fmt"
    "strings"

    {{- range $i, $field := .Imports }}
    "{{ $field.Path }}"
    {{- end }}
)

var (
    Err{{ .Repo.Model.Name }}Scan = errors.New("scan")
    Err{{ .Repo.Model.Name }}NotFound = errors.New("not found")
)

type {{ .Repo.Model.Name }}Scanner interface {
    Scan(dest ...any) error
}

type {{ .Repo.Model.Name }}Repo struct {
    db    *sql.DB
    table string

    stateCols []string

    keyCols []string

    cols []string
}

func New{{ .Repo.Model.Name }}Repo(db *sql.DB, table string) *{{ .Repo.Model.Name }}Repo {
    keyCols := []string{
        {{- range $i, $field := .Repo.ColKeysFields }}
            "{{ $field.ColName }}",
        {{- end}}
    }

    stateCols := []string{
        {{- range $i, $field := .Repo.ColStatesFields }}
            "{{ $field.ColName }}",
        {{- end}}
    }

    cols := append(keyCols, stateCols...)

    return &{{ .Repo.Model.Name }}Repo{
        db:    db,
        table: table,

        keyCols: keyCols,
        stateCols: stateCols,
        cols: cols,
    }
}

func ({{ .Repo.Receiver }} *{{ .Repo.Model.Name }}Repo) Scan(_ context.Context, s {{ .Repo.Model.Name }}Scanner) (*{{ .Repo.Model.Name }}, error) {
    var (
        m {{ .Repo.Model.Name }}
        {{- range $i, $field := .Repo.ColKeysFields }}
            {{ $field | fieldType }}
        {{- end }}
        {{- range $i, $field := .Repo.ColStatesFields }}
            {{ $field | fieldType }}
        {{- end }}
    )

    err := s.Scan(
        {{- range $i, $field := .Repo.ColKeysFields }}
            {{ $field | scanField }},
        {{- end }}
        {{- range $i, $field := .Repo.ColStatesFields }}
            {{ $field | scanField }},
        {{- end }}
    )
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, Err{{ .Repo.Model.Name }}NotFound
        }

        return nil, errors.WrapWithError(err, Err{{ .Repo.Model.Name }}Scan)
    }

    {{- range $i, $field := .Repo.ColKeysFields }}
        {{ $field | sqlToField }}
    {{- end }}
    {{- range $i, $field := .Repo.ColStatesFields }}
        {{ $field | sqlToField }}
    {{- end }}

    return &m, nil
}

func ({{ .Repo.Receiver }} *{{ .Repo.Model.Name }}Repo) ScanAll(ctx context.Context, rs *sql.Rows) ([]*{{ .Repo.Model.Name }}, error) {
    var ms []*{{ .Repo.Model.Name }}

    for rs.Next() {
        m, err := {{ .Repo.Receiver }}.Scan(ctx, rs)
        if err != nil {
            return nil, err
        }

        ms = append(ms, m)
    }

    if len(ms) == 0 {
        return nil, Err{{ .Repo.Model.Name }}NotFound
    }

    return ms, nil
}

func ({{ .Repo.Receiver }} *{{ .Repo.Model.Name }}Repo) Create(ctx context.Context, m *{{ .Repo.Model.Name }}) (*{{ .Repo.Model.Name }}, error) {
    var (
        cols []string
        args []interface{}
    )

    {{- range $i, $field := .Repo.ColKeysFields }}
        {{ $field | fieldToSql }}
    {{- end }}
    {{- range $i, $field := .Repo.ColStatesFields }}
        {{ $field | fieldToSql }}
    {{- end }}

    values := make([]string, len(cols))

    for i := range cols {
        values[i] = fmt.Sprintf("$%d", i+1)
    }

    qCols := strings.Join(cols, ", ")
    qValues := strings.Join(values, ", ")

    {{if .Repo.Model.Auto}}
    rCols := strings.Join({{ .Repo.Receiver }}.cols, ", ")

    sql := "INSERT INTO %s (%s) VALUES (%s) RETURNING %s"
    sql = fmt.Sprintf(sql, {{ .Repo.Receiver }}.table, qCols, qValues, rCols)

    return  {{ .Repo.Receiver }}.Scan(ctx, {{ .Repo.Receiver }}.db.QueryRowContext(ctx, sql, args...))
}
    {{else}}
    sql := "INSERT INTO %s (%s) VALUES (%s)"
    sql = fmt.Sprintf(sql, {{ .Repo.Receiver }}.table, qCols, qValues)

    _, err := {{ .Repo.Receiver }}.db.ExecContext(ctx, sql, args...)
    if err != nil {
        return nil, errors.Wrap(err, "exec context")
    }

    return  m, nil
}
    {{end}}
