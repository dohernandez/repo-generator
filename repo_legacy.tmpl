package {{.Package}}

// Code generated by repo-generator. DO NOT EDIT.

import (
    "context"
    "database/sql"
    "fmt"
    "strings"

    {{- range $i, $field := .Imports }}
    "{{ $field.Path }}"
    {{- end }}
)

var (
    Err{{ .ModelBuilder.TypeName }}Scan = errors.New("scan")
    Err{{ .ModelBuilder.TypeName }}NotFound = errors.New("not found")
)

type {{ .ModelBuilder.TypeName }}Scanner interface {
    Scan(dest ...any) error
}

type {{ .ModelBuilder.TypeName }}Repo struct {
    db    *sql.DB
    table string

    cols []string

    keyCols []string
}

func New{{ .ModelBuilder.TypeName }}Repo(db *sql.DB, table string) *{{ .ModelBuilder.TypeName }}Repo {
    keyCols := []string{
        {{- range $i, $field := .ModelBuilder.KeyFields }}
        "{{ $field.Key }}",
        {{- end}}
    }

    return &{{ .ModelBuilder.TypeName }}Repo{
        db:    db,
        table: table,

        cols: []string{
            {{- range $i, $field := .ModelBuilder.KeyFields }}
            "{{ $field.Key }}",
            {{- end}}
            {{- range $i, $field := .ModelBuilder.StateFields }}
            "{{ $field.Key }}",
            {{- end}}
        },

        keyCols: keyCols,
    }
}

func ({{ .ModelBuilder.Receiver }} *{{ .ModelBuilder.TypeName }}Repo) Create(ctx context.Context, m *{{ .ModelBuilder.TypeName }}) (*{{ .ModelBuilder.TypeName }}, error) {
    var (
        cols []string
        args []interface{}
    )

    {{- range $i, $field := .ModelBuilder.KeyFields }}
       {{ $field | fieldToSql }}
    {{- end }}
    {{- range $i, $field := .ModelBuilder.StateFields }}
       {{ $field | fieldToSql }}
    {{- end }}

    values := make([]string, len(cols))

    for i := range cols {
        values[i] = fmt.Sprintf("$%d", i+1)
    }

    qCols := strings.Join(cols, ", ")
    qValues := strings.Join(values, ", ")
    rCols := strings.Join({{ .ModelBuilder.Receiver }}.cols, ", ")

    q := "INSERT INTO %s (%s) VALUES (%s) RETURNING %s"
    q = fmt.Sprintf(q, {{ .ModelBuilder.Receiver }}.table, qCols, qValues, rCols)

    return  {{ .ModelBuilder.Receiver }}.Scan({{ .ModelBuilder.Receiver }}.db.QueryRowContext(ctx, q, args...))
}

{{/*func ({{ .ModelBuilder.Receiver }} *{{ .ModelBuilder.TypeName }}Repo) Create(ctx context.Context, m *{{ .ModelBuilder.TypeName }}) (*{{ .ModelBuilder.TypeName }}, error) {*/}}
{{/*    values := make([]string, len({{ .ModelBuilder.Receiver }}.cols))*/}}

{{/*    for i := range {{ .ModelBuilder.Receiver }}.cols {*/}}
{{/*        values[i] = fmt.Sprintf("$%d", i+1)*/}}
{{/*    }*/}}

{{/*    args := make([]interface{}, 0, len({{ .ModelBuilder.Receiver }}.cols))*/}}

{{/*    {{- range $i, $field := .ModelBuilder.KeyFields }}*/}}
{{/*       {{ $field | fieldToArg }}*/}}
{{/*       args = append(args, {{ $field | fieldArg }})*/}}
{{/*    {{- end }}*/}}
{{/*    {{- range $i, $field := .ModelBuilder.StateFields }}*/}}
{{/*       {{ $field | fieldToArg }}*/}}
{{/*       args = append(args, {{ $field | fieldArg }})*/}}
{{/*    {{- end }}*/}}

{{/*    qCols := strings.Join({{ .ModelBuilder.Receiver }}.cols, ", ")*/}}
{{/*    qValues := strings.Join(values, ", ")*/}}

{{/*    q := "INSERT INTO %s (%s) VALUES (%s) RETURNING %s"*/}}
{{/*    q = fmt.Sprintf(q, {{ .ModelBuilder.Receiver }}.table, qCols, qValues, qCols)*/}}

{{/*    return  {{ .ModelBuilder.Receiver }}.Scan({{ .ModelBuilder.Receiver }}.db.QueryRowContext(ctx, q, args...))*/}}
{{/*}*/}}

func ({{ .ModelBuilder.Receiver }} *{{ .ModelBuilder.TypeName }}Repo) Scan(s {{ .ModelBuilder.TypeName }}Scanner) (*{{ .ModelBuilder.TypeName }}, error) {
    var (
        m {{ .ModelBuilder.TypeName }}
        {{- range $i, $field := .ModelBuilder.KeyFields }}
        {{ $field | fieldToScan }}
        {{- end }}
        {{- range $i, $field := .ModelBuilder.StateFields }}
        {{ $field | fieldToScan }}
        {{- end }}
    )

    err := s.Scan(
        {{- range $i, $field := .ModelBuilder.KeyFields }}
        {{ $field | fieldScanning }},
        {{- end }}
        {{- range $i, $field := .ModelBuilder.StateFields }}
        {{ $field | fieldScanning }},
        {{- end }}
    )
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, Err{{ .ModelBuilder.TypeName }}NotFound
        }

        return nil, errors.WrapWithError(err, Err{{ .ModelBuilder.TypeName }}Scan)
    }

    {{- range $i, $field := .ModelBuilder.KeyFields }}
    {{ $field | scanToField }}
    {{- end }}
    {{- range $i, $field := .ModelBuilder.StateFields }}
    {{ $field | scanToField }}
    {{- end }}

    return &m, nil
}

func ({{ .ModelBuilder.Receiver }} *{{ .ModelBuilder.TypeName }}Repo) ScanAll(rs *sql.Rows) ([]*{{ .ModelBuilder.TypeName }}, error) {
    var ms []*{{ .ModelBuilder.TypeName }}

    for rs.Next() {
        m, err := {{ .ModelBuilder.Receiver }}.Scan(rs)
        if err != nil {
            return nil, err
        }

        ms = append(ms, m)
    }

    if len(ms) == 0 {
        return nil, Err{{ .ModelBuilder.TypeName }}NotFound
    }

    return ms, nil
}

{{/*func ({{ .ModelBuilder.Receiver }} *{{ .ModelBuilder.TypeName }}Repo)  Lookup(ctx context.Context, {{- range $i, $field := .ModelBuilder.KeyFields }}{{ $field.Name | toLowerCamel }} {{ $field.Type }}, {{- end}}) (*{{ .ModelBuilder.TypeName }}, error) {*/}}
{{/*    q := "SELECT * FROM %s WHERE {{- range $i, $field := .ModelBuilder.KeyFields }} {{ $field.Name | toLowerCamel }} = ${{ inc $i }}{{ $i | AND }}{{- end}}"*/}}
{{/*    q = fmt.Sprintf(q, {{ .ModelBuilder.Receiver }}.table)*/}}

{{/*    return {{ .ModelBuilder.Receiver }}.Scan({{ .ModelBuilder.Receiver }}.db.QueryRowContext(ctx, q, {{- range $i, $field := .ModelBuilder.KeyFields }}{{ $field.Name | toLowerCamel }}, {{- end}}))*/}}
{{/*}*/}}
