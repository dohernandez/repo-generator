package foo

// Code generated by repo-generator. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/dohernandez/repo-generator/errors"
	"github.com/dohernandez/repo-generator/testdata/deps"
	"github.com/lib/pq"
	"strings"
)

var (
	ErrAssetScan     = errors.New("scan")
	ErrAssetNotFound = errors.New("not found")
)

type AssetScanner interface {
	Scan(dest ...any) error
}

type AssetRepo struct {
	db    *sql.DB
	table string

	stateCols []string

	keyCols []string

	cols []string
}

func NewAssetRepo(db *sql.DB, table string) *AssetRepo {
	keyCols := []string{
		"chain_id",
		"address",
	}

	stateCols := []string{
		"block_hash",
		"types",
		"name",
		"symbol",
		"metadata",
		"immutable",
		"created_at",
		"updated_at",
	}

	cols := append(keyCols, stateCols...)

	return &AssetRepo{
		db:    db,
		table: table,

		keyCols:   keyCols,
		stateCols: stateCols,
		cols:      cols,
	}
}

func (repo *AssetRepo) Scan(_ context.Context, s AssetScanner) (*Asset, error) {
	var (
		m Asset

		address   string
		blockHash string
		typs      pq.StringArray
	)

	err := s.Scan(
		&m.ChainID,
		&address,
		&blockHash,
		&typs,
		&m.Name,
		&m.Symbol,
		&m.Metadata,
		&m.Immutable,
		&m.CreatedAt,
		&m.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrAssetNotFound
		}

		return nil, errors.WrapWithError(err, ErrAssetScan)
	}

	m.Address = deps.HexToAddress(address)
	m.BlockHash = deps.HexToHash(blockHash)

	for i := range typs {
		m.Type = append(m.Type, deps.AssetContractType(typs[i]))
	}

	return &m, nil
}

func (repo *AssetRepo) ScanAll(ctx context.Context, rs *sql.Rows) ([]*Asset, error) {
	var ms []*Asset

	for rs.Next() {
		m, err := repo.Scan(ctx, rs)
		if err != nil {
			return nil, err
		}

		ms = append(ms, m)
	}

	if len(ms) == 0 {
		return nil, ErrAssetNotFound
	}

	return ms, nil
}

func (repo *AssetRepo) Create(ctx context.Context, m *Asset) (*Asset, error) {
	var (
		cols []string
		args []interface{}
	)

	cols = append(cols, "chain_id")
	args = append(args, m.ChainID)

	cols = append(cols, "address")
	args = append(args, m.Address.String())

	cols = append(cols, "block_hash")
	args = append(args, m.BlockHash.String())

	cols = append(cols, "types")

	typs := make([]string, len(m.Type))

	for i := range m.Type {
		typs[i] = string(m.Type[i])
	}

	args = append(args, typs)

	cols = append(cols, "name")
	args = append(args, m.Name)

	cols = append(cols, "symbol")
	args = append(args, m.Symbol)

	cols = append(cols, "metadata")
	args = append(args, m.Metadata)

	cols = append(cols, "immutable")
	args = append(args, m.Immutable)

	cols = append(cols, "created_at")
	args = append(args, m.CreatedAt)

	cols = append(cols, "updated_at")
	args = append(args, m.UpdatedAt)

	values := make([]string, len(cols))

	for i := range cols {
		values[i] = fmt.Sprintf("$%d", i+1)
	}

	qCols := strings.Join(cols, ", ")
	qValues := strings.Join(values, ", ")

	sql := "INSERT INTO %s (%s) VALUES (%s)"
	sql = fmt.Sprintf(sql, repo.table, qCols, qValues)

	_, err := repo.db.ExecContext(ctx, sql, args...)
	if err != nil {
		return nil, errors.Wrap(err, "exec context")
	}

	return m, nil

}
