package foo

// Code generated by repo-generator v0.1.0. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"math/big"

	"github.com/dohernandez/errors"
	"github.com/dohernandez/repo-generator/testdata/deps"
	"github.com/jackc/pgerrcode"
	"github.com/jackc/pgx/v5/pgconn"
)

var (
	// ErrBlockScan is the error that indicates a Block scan failed.
	ErrBlockScan = errors.New("scan")
	// ErrBlockNotFound is the error that indicates a Block was not found.
	ErrBlockNotFound = errors.New("not found")
	// ErrBlockExists is returned when the Block already exists.
	ErrBlockExists = errors.New("exists")
)

// BlockRow is an interface for anything that can scan a Block, copying the columns from the matched
// row into the values pointed at by dest.
type BlockRow interface {
	Scan(dest ...any) error
}

// BlockSQLDB is an interface for anything that can execute the SQL statements needed to
// perform the Block operations.
type BlockSQLDB interface {
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
	ExecContext(ctx context.Context, q string, args ...interface{}) (sql.Result, error)
	BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error)
}

// BlockRepo is a repository for the Block.
type BlockRepo struct {
	// db is the database connection.
	db BlockSQLDB

	// table is the table name.
	table string

	// colID is the Block.ID column name. It can be used in a queries to specify the column.
	colID string
	// colChainID is the Block.ChainID column name. It can be used in a queries to specify the column.
	colChainID string
	// colHash is the Block.Hash column name. It can be used in a queries to specify the column.
	colHash string
	// colNumber is the Block.Number column name. It can be used in a queries to specify the column.
	colNumber string
	// colParentHash is the Block.ParentHash column name. It can be used in a queries to specify the column.
	colParentHash string
	// colBlockTimestamp is the Block.BlockTimestamp column name. It can be used in a queries to specify the column.
	colBlockTimestamp string
}

// NewBlockRepo creates a new BlockRepo.
func NewBlockRepo(db BlockSQLDB, table string) *BlockRepo {
	return &BlockRepo{
		db:    db,
		table: table,

		colID:             "id",
		colChainID:        "chain_id",
		colHash:           "hash",
		colNumber:         "number",
		colParentHash:     "parent_hash",
		colBlockTimestamp: "block_timestamp",
	}
}

// Table returns the table name.
func (repo *BlockRepo) Table() string {
	return repo.table
}

// Cols returns the represented cols of Block.
// Cols are returned in the order they are scanned.
func (repo *BlockRepo) Cols() []string {
	return []string{
		repo.colID,
		repo.colChainID,
		repo.colHash,
		repo.colNumber,
		repo.colParentHash,
		repo.colBlockTimestamp,
	}
}

// Scan scans a Block from the given BlockRow (sql.Row|sql.Rows).
func (repo *BlockRepo) Scan(_ context.Context, s BlockRow) (*Block, error) {
	var (
		m Block

		chainID        int
		hash           sql.NullString
		number         int64
		parentHash     sql.NullString
		blockTimestamp sql.NullTime
	)

	err := s.Scan(
		&m.ID,
		&chainID,
		&hash,
		&number,
		&parentHash,
		&blockTimestamp,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrBlockNotFound
		}

		var pgErr *pgconn.PgError

		if errors.As(err, &pgErr) && pgErr.Code == pgerrcode.UniqueViolation {
			return nil, errors.WrapError(err, ErrBlockExists)
		}

		return nil, errors.WrapError(err, ErrBlockScan)
	}

	m.ChainID = deps.ChainID(chainID)

	if hash.Valid {
		m.Hash = deps.HexToHash(hash.String)
	}

	m.Number = big.NewInt(number)

	if parentHash.Valid {
		m.ParentHash = deps.HexToHash(parentHash.String)
	}

	if blockTimestamp.Valid {
		m.BlockTimestamp = blockTimestamp.Time.UTC()
	}

	return &m, nil
}

// ScanAll scans a slice of Block from the given sql.Rows.
func (repo *BlockRepo) ScanAll(ctx context.Context, rs *sql.Rows) ([]*Block, error) {
	var ms []*Block

	for rs.Next() {
		m, err := repo.Scan(ctx, rs)
		if err != nil {
			return nil, err
		}

		ms = append(ms, m)
	}

	if len(ms) == 0 {
		return nil, ErrBlockNotFound
	}

	return ms, nil
}
