package foo

// Code generated by repo-generator v0.1.0. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"math/big"
	"strings"

	"github.com/dohernandez/errors"
	"github.com/dohernandez/repo-generator/testdata/deps"
)

var (
	ErrBlockScan     = errors.New("scan")
	ErrBlockNotFound = errors.New("not found")
	ErrBlockUpdate   = errors.New("update")
)

type BlockScanner interface {
	Scan(dest ...any) error
}

type BlockRepo struct {
	db *sql.DB

	table             string
	colID             string
	colChainID        string
	colHash           string
	colNumber         string
	colParentHash     string
	colBlockTimestamp string

	cols []string
}

func NewBlockRepo(db *sql.DB, table string) *BlockRepo {
	cols := []string{
		"id",
		"chain_id",
		"hash",
		"number",
		"parent_hash",
		"block_timestamp",
	}

	return &BlockRepo{
		db:                db,
		table:             table,
		colID:             "id",
		colChainID:        "chain_id",
		colHash:           "hash",
		colNumber:         "number",
		colParentHash:     "parent_hash",
		colBlockTimestamp: "block_timestamp",

		cols: cols,
	}
}

func (repo *BlockRepo) Scan(_ context.Context, s BlockScanner) (*Block, error) {
	var (
		m Block

		hash           sql.NullString
		number         int64
		parentHash     sql.NullString
		blockTimestamp sql.NullTime
	)

	err := s.Scan(
		&m.ID,
		&m.ChainID,
		&hash,
		&number,
		&parentHash,
		&blockTimestamp,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrBlockNotFound
		}

		return nil, errors.WrapError(err, ErrBlockScan)
	}

	if hash.Valid {
		m.Hash = deps.HexToHash(hash.String)
	}

	m.Number = big.NewInt(number)

	if parentHash.Valid {
		m.ParentHash = deps.HexToHash(parentHash.String)
	}

	if blockTimestamp.Valid {
		m.BlockTimestamp = blockTimestamp.Time.UTC()
	}

	return &m, nil
}

func (repo *BlockRepo) ScanAll(ctx context.Context, rs *sql.Rows) ([]*Block, error) {
	var ms []*Block

	for rs.Next() {
		m, err := repo.Scan(ctx, rs)
		if err != nil {
			return nil, err
		}

		ms = append(ms, m)
	}

	if len(ms) == 0 {
		return nil, ErrBlockNotFound
	}

	return ms, nil
}

func (repo *BlockRepo) Create(ctx context.Context, m *Block) (*Block, error) {
	var (
		cols []string
		args []interface{}
	)

	if !deps.IsUUIDZero(m.ID) {
		cols = append(cols, repo.colID)
		args = append(args, m.ID)
	}

	cols = append(cols, repo.colChainID)
	args = append(args, m.ChainID)

	var hash sql.NullString

	hash.String = m.Hash.String()
	hash.Valid = true

	cols = append(cols, repo.colHash)
	args = append(args, hash)

	if m.Number != nil {
		cols = append(cols, repo.colNumber)
		args = append(args, m.Number.Int64())
	}

	var parentHash sql.NullString

	parentHash.String = m.ParentHash.String()
	parentHash.Valid = true

	cols = append(cols, repo.colParentHash)
	args = append(args, parentHash)

	if !m.BlockTimestamp.IsZero() {
		var blockTimestamp sql.NullTime

		blockTimestamp.Time = m.BlockTimestamp
		blockTimestamp.Valid = true

		cols = append(cols, repo.colBlockTimestamp)
		args = append(args, blockTimestamp)
	}

	values := make([]string, len(cols))

	for i := range cols {
		values[i] = fmt.Sprintf("$%d", i+1)
	}

	qCols := strings.Join(cols, ", ")
	qValues := strings.Join(values, ", ")

	rCols := strings.Join(repo.cols, ", ")

	sql := "INSERT INTO %s (%s) VALUES (%s) RETURNING %s"
	sql = fmt.Sprintf(sql, repo.table, qCols, qValues, rCols)

	return repo.Scan(ctx, repo.db.QueryRowContext(ctx, sql, args...))
}

func (repo *BlockRepo) Insert(ctx context.Context, ms ...*Block) error {
	// Build values query.
	var (
		valuesQueryBuilder strings.Builder
		lms                = len(ms)
	)

	var cols []string
	cols = append(cols, repo.colID)
	cols = append(cols, repo.colChainID)
	cols = append(cols, repo.colHash)
	cols = append(cols, repo.colNumber)
	cols = append(cols, repo.colParentHash)
	cols = append(cols, repo.colBlockTimestamp)

	lcols := len(cols)

	// Size is equal to the number of models (lms) multiplied by the number of columns (lcols).
	args := make([]interface{}, 0, lms*lcols)

	for i := range ms {
		m := ms[i]

		indexOffset := i * lcols

		valuesQueryBuilder.WriteString(repo.valuesStatement(cols, indexOffset, i != lms-1))

		if !deps.IsUUIDZero(m.ID) {
			args = append(args, m.ID)
		} else {
			args = append(args, nil)
		}

		args = append(args, m.ChainID)

		var hash sql.NullString

		hash.String = m.Hash.String()
		hash.Valid = true

		args = append(args, hash)

		if m.Number != nil {
			args = append(args, m.Number.Int64())
		} else {
			args = append(args, nil)
		}

		var parentHash sql.NullString

		parentHash.String = m.ParentHash.String()
		parentHash.Valid = true

		args = append(args, parentHash)

		var blockTimestamp sql.NullTime

		if !m.BlockTimestamp.IsZero() {
			blockTimestamp.Time = m.BlockTimestamp
			blockTimestamp.Valid = true
		}

		args = append(args, blockTimestamp)

	}

	qCols := strings.Join(cols, ", ")

	sql := "INSERT INTO %s (%s) VALUES %s"
	sql = fmt.Sprintf(sql, repo.table, qCols, valuesQueryBuilder.String())

	_, err := repo.db.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "exec context")
	}

	return nil
}

func (repo *BlockRepo) valuesStatement(cols []string, offset int, separator bool) string {
	var sep string

	if separator {
		sep = ","
	}

	values := make([]string, len(cols))
	for i := range cols {
		values[i] = fmt.Sprintf("$%d", offset+(i+1))
	}

	return fmt.Sprintf("(%s)%s", strings.Join(values, ", "), sep)
}

func (repo *BlockRepo) Update(ctx context.Context, m *Block, skipZeroValues bool) error {
	var (
		sets   []string
		where  []string
		args   []interface{}
		offset = 1
	)

	where = append(where, fmt.Sprintf("%s = $%d", repo.colID, offset))
	args = append(args, m.ID)

	offset++

	if skipZeroValues {

		sets = append(sets, fmt.Sprintf("%s = $%d", repo.colChainID, offset))
		args = append(args, m.ChainID)

		offset++

		sets = append(sets, fmt.Sprintf("%s = $%d", repo.colHash, offset))
		args = append(args, m.Hash.String())

		offset++

		if m.Number != nil {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colNumber, offset))
			args = append(args, m.Number.Int64())

			offset++
		}

		sets = append(sets, fmt.Sprintf("%s = $%d", repo.colParentHash, offset))
		args = append(args, m.ParentHash.String())

		offset++

		sets = append(sets, fmt.Sprintf("%s = $%d", repo.colBlockTimestamp, offset))
		args = append(args, m.BlockTimestamp)

		offset++

	} else {

		where = append(where, fmt.Sprintf("%s = $%d", repo.colChainID, offset))
		args = append(args, m.ChainID)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colHash, offset))
		args = append(args, m.Hash)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colNumber, offset))
		args = append(args, m.Number)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colParentHash, offset))
		args = append(args, m.ParentHash)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colBlockTimestamp, offset))
		args = append(args, m.BlockTimestamp)

		offset++
	}

	qSets := strings.Join(sets, ", ")
	qWhere := strings.Join(where, " AND ")

	sql := "UPDATE %s SET %s WHERE %s"
	sql = fmt.Sprintf(sql, repo.table, qSets, qWhere)

	res, err := repo.db.ExecContext(ctx, sql, args...)
	if err != nil {
		return err
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected == 0 {
		return ErrBlockUpdate
	}

	return nil
}
