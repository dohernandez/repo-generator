package foo

// Code generated by repo-generator. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/dohernandez/errors"
	"github.com/google/uuid"
	"strings"
)

var (
	ErrCursorScan     = errors.New("scan")
	ErrCursorNotFound = errors.New("not found")
)

type CursorScanner interface {
	Scan(dest ...any) error
}

type CursorRepo struct {
	db    *sql.DB
	table string

	stateCols []string

	keyCols []string

	cols []string
}

func NewCursorRepo(db *sql.DB, table string) *CursorRepo {
	keyCols := []string{
		"id",
	}

	stateCols := []string{
		"name",
		"position",
		"leader",
		"leader_elected_at",
		"created_at",
		"updated_at",
	}

	cols := append(keyCols, stateCols...)

	return &CursorRepo{
		db:    db,
		table: table,

		keyCols:   keyCols,
		stateCols: stateCols,
		cols:      cols,
	}
}

func (repo *CursorRepo) Scan(_ context.Context, s CursorScanner) (*Cursor, error) {
	var (
		m Cursor

		position        sql.NullString
		leader          sql.NullString
		leaderElectedAt sql.NullTime
	)

	err := s.Scan(
		&m.ID,
		&m.Name,
		&position,
		&leader,
		&leaderElectedAt,
		&m.CreatedAt,
		&m.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrCursorNotFound
		}

		return nil, errors.WrapError(err, ErrCursorScan)
	}

	if position.Valid {
		m.Position = uuid.MustParse(position.String)
	}

	if leader.Valid {
		m.Leader = uuid.MustParse(leader.String)
	}

	if leaderElectedAt.Valid {
		m.LeaderElectedAt = leaderElectedAt.Time
	}

	return &m, nil
}

func (repo *CursorRepo) ScanAll(ctx context.Context, rs *sql.Rows) ([]*Cursor, error) {
	var ms []*Cursor

	for rs.Next() {
		m, err := repo.Scan(ctx, rs)
		if err != nil {
			return nil, err
		}

		ms = append(ms, m)
	}

	if len(ms) == 0 {
		return nil, ErrCursorNotFound
	}

	return ms, nil
}

func (repo *CursorRepo) Create(ctx context.Context, m *Cursor) (*Cursor, error) {
	var (
		cols []string
		args []interface{}
	)

	cols = append(cols, "id")
	args = append(args, m.ID)

	cols = append(cols, "name")
	args = append(args, m.Name)

	var position sql.NullString

	position.String = m.Position.String()
	position.Valid = true

	cols = append(cols, "position")
	args = append(args, position)

	var leader sql.NullString

	leader.String = m.Leader.String()
	leader.Valid = true

	cols = append(cols, "leader")
	args = append(args, leader)

	var leaderElectedAt sql.NullTime

	leaderElectedAt.Time = m.LeaderElectedAt
	leaderElectedAt.Valid = true

	cols = append(cols, "leader_elected_at")
	args = append(args, leaderElectedAt)

	cols = append(cols, "created_at")
	args = append(args, m.CreatedAt)

	cols = append(cols, "updated_at")
	args = append(args, m.UpdatedAt)

	values := make([]string, len(cols))

	for i := range cols {
		values[i] = fmt.Sprintf("$%d", i+1)
	}

	qCols := strings.Join(cols, ", ")
	qValues := strings.Join(values, ", ")

	sql := "INSERT INTO %s (%s) VALUES (%s)"
	sql = fmt.Sprintf(sql, repo.table, qCols, qValues)

	_, err := repo.db.ExecContext(ctx, sql, args...)
	if err != nil {
		return nil, errors.Wrap(err, "exec context")
	}

	return m, nil
}

func (repo *CursorRepo) Insert(ctx context.Context, ms ...*Cursor) error {
	// Build values query.
	var (
		valuesQueryBuilder strings.Builder
		lms                = len(ms)
	)

	var cols []string
	cols = append(cols, "id")
	cols = append(cols, "name")
	cols = append(cols, "position")
	cols = append(cols, "leader")
	cols = append(cols, "leader_elected_at")
	cols = append(cols, "created_at")
	cols = append(cols, "updated_at")

	lcols := len(cols)

	// Size is equal to the number of models (lms) multiplied by the number of columns (lcols).
	args := make([]interface{}, 0, lms*lcols)

	for i := range ms {
		m := ms[i]

		indexOffset := i * lcols
		valuesQueryBuilder.WriteString(repo.valuesStatement(cols, indexOffset, i != lms-1))

		args = append(args, m.ID)

		args = append(args, m.Name)

		var position sql.NullString

		position.String = m.Position.String()
		position.Valid = true

		args = append(args, position)

		var leader sql.NullString

		leader.String = m.Leader.String()
		leader.Valid = true

		args = append(args, leader)

		var leaderElectedAt sql.NullTime

		leaderElectedAt.Time = m.LeaderElectedAt
		leaderElectedAt.Valid = true

		args = append(args, leaderElectedAt)

		args = append(args, m.CreatedAt)

		args = append(args, m.UpdatedAt)

	}

	qCols := strings.Join(cols, ", ")

	sql := "INSERT INTO %s (%s) VALUES %s"
	sql = fmt.Sprintf(sql, repo.table, qCols, valuesQueryBuilder.String())

	_, err := repo.db.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "exec context")
	}

	return nil
}

func (repo *CursorRepo) valuesStatement(cols []string, offset int, separator bool) string {
	var sep string

	if separator {
		sep = ","
	}

	values := make([]string, len(cols))
	for i := range cols {
		values[i] = fmt.Sprintf("$%d", offset+(i+1))
	}

	return fmt.Sprintf("(%s)%s", strings.Join(values, ", "), sep)
}
