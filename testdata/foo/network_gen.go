package foo

// Code generated by repo-generator. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/dohernandez/repo-generator/errors"
	"math/big"
	"strings"
)

var (
	ErrNetworkScan     = errors.New("scan")
	ErrNetworkNotFound = errors.New("not found")
)

type NetworkScanner interface {
	Scan(dest ...any) error
}

type NetworkRepo struct {
	db    *sql.DB
	table string

	stateCols []string

	keyCols []string

	cols []string
}

func NewNetworkRepo(db *sql.DB, table string) *NetworkRepo {
	keyCols := []string{
		"id",
		"token",
	}

	stateCols := []string{
		"uri",
		"number",
		"total",
		"ip",
		"created_at",
		"updated_at",
	}

	cols := append(keyCols, stateCols...)

	return &NetworkRepo{
		db:    db,
		table: table,

		keyCols:   keyCols,
		stateCols: stateCols,
		cols:      cols,
	}
}

func (repo *NetworkRepo) Scan(_ context.Context, s NetworkScanner) (*Network, error) {
	var (
		m Network

		uRI    sql.NullString
		number sql.NullInt64
		total  int64
		iP     string
	)

	err := s.Scan(
		&m.ID,
		&m.Token,
		&uRI,
		&number,
		&total,
		&iP,
		&m.CreatedAt,
		&m.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNetworkNotFound
		}

		return nil, errors.WrapWithError(err, ErrNetworkScan)
	}

	if uRI.Valid {
		m.URI = uRI.String
	}

	if number.Valid {
		m.Number = big.NewInt(number.Int64)
	}

	m.Total = bigNewInt(total)

	tmp := iP
	m.IP = &tmp

	return &m, nil
}

func (repo *NetworkRepo) ScanAll(ctx context.Context, rs *sql.Rows) ([]*Network, error) {
	var ms []*Network

	for rs.Next() {
		m, err := repo.Scan(ctx, rs)
		if err != nil {
			return nil, err
		}

		ms = append(ms, m)
	}

	if len(ms) == 0 {
		return nil, ErrNetworkNotFound
	}

	return ms, nil
}

func (repo *NetworkRepo) Create(ctx context.Context, m *Network) (*Network, error) {
	var (
		cols []string
		args []interface{}
	)

	cols = append(cols, "token")
	args = append(args, m.Token)

	var uRI sql.NullString

	uRI.String = m.URI
	uRI.Valid = true

	cols = append(cols, "uri")
	args = append(args, uRI)

	if m.Number != nil {
		var number sql.NullInt64

		number.Int64 = m.Number.Int64()
		number.Valid = true

		cols = append(cols, "number")
		args = append(args, number)
	}

	cols = append(cols, "total")
	args = append(args, m.Total.Int64())

	if m.IP != nil {
		cols = append(cols, "ip")
		args = append(args, *m.IP)
	}

	values := make([]string, len(cols))

	for i := range cols {
		values[i] = fmt.Sprintf("$%d", i+1)
	}

	qCols := strings.Join(cols, ", ")
	qValues := strings.Join(values, ", ")

	rCols := strings.Join(repo.cols, ", ")

	sql := "INSERT INTO %s (%s) VALUES (%s) RETURNING %s"
	sql = fmt.Sprintf(sql, repo.table, qCols, qValues, rCols)

	return repo.Scan(ctx, repo.db.QueryRowContext(ctx, sql, args...))

}
