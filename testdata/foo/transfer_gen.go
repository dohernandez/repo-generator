package foo

// Code generated by repo-generator v0.1.0. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"math/big"
	"strings"
	"time"

	"github.com/dohernandez/errors"
	"github.com/dohernandez/repo-generator/testdata/deps"
)

var (
	ErrTransferScan     = errors.New("scan")
	ErrTransferNotFound = errors.New("not found")
	ErrTransferUpdate   = errors.New("update")
)

type TransferScanner interface {
	Scan(dest ...any) error
}

type TransferRepo struct {
	db *sql.DB

	table              string
	colID              string
	colChainID         string
	colBlockHash       string
	colBlockTimestamp  string
	colTransactionHash string
	colMethodID        string
	colFromAddress     string
	colToAddress       string
	colAssetContract   string
	colValue           string
	colMetadata        string
	colTraceAddress    string
	colCreatedAt       string

	cols []string
}

func NewTransferRepo(db *sql.DB, table string) *TransferRepo {
	cols := []string{
		"id",
		"chain_id",
		"block_hash",
		"block_timestamp",
		"transaction_hash",
		"method_id",
		"from_address",
		"to_address",
		"asset_contract",
		"value",
		"metadata",
		"trace_address",
		"created_at",
	}

	return &TransferRepo{
		db:                 db,
		table:              table,
		colID:              "id",
		colChainID:         "chain_id",
		colBlockHash:       "block_hash",
		colBlockTimestamp:  "block_timestamp",
		colTransactionHash: "transaction_hash",
		colMethodID:        "method_id",
		colFromAddress:     "from_address",
		colToAddress:       "to_address",
		colAssetContract:   "asset_contract",
		colValue:           "value",
		colMetadata:        "metadata",
		colTraceAddress:    "trace_address",
		colCreatedAt:       "created_at",

		cols: cols,
	}
}

func (repo *TransferRepo) Scan(_ context.Context, s TransferScanner) (*Transfer, error) {
	var (
		m Transfer

		blockHash string

		transactionHash sql.NullString
		methodID        sql.NullString
		fromAddress     string
		toAddress       sql.NullString
		assetContract   string
		value           int64

		createdAt time.Time
	)

	err := s.Scan(
		&m.ID,
		&m.ChainID,
		&blockHash,
		&m.BlockTimestamp,
		&transactionHash,
		&methodID,
		&fromAddress,
		&toAddress,
		&assetContract,
		&value,
		&m.Metadata,
		&m.TraceAddress,
		&m.CreatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrTransferNotFound
		}

		return nil, errors.WrapError(err, ErrTransferScan)
	}

	m.BlockHash = deps.HexToHash(blockHash)

	if transactionHash.Valid {
		m.TransactionHash = toTransactionHash(transactionHash.String)
	}

	if methodID.Valid {
		tmp := methodID.String
		m.MethodID = &tmp
	}

	m.FromAddress = deps.HexToAddress(fromAddress)

	if toAddress.Valid {
		m.ToAddress = deps.HexToAddress(toAddress.String)
	}

	m.AssetContract = deps.HexToAddress(assetContract)

	m.Value = big.NewInt(value)

	m.CreatedAt = createdAt.UTC()

	return &m, nil
}

func (repo *TransferRepo) ScanAll(ctx context.Context, rs *sql.Rows) ([]*Transfer, error) {
	var ms []*Transfer

	for rs.Next() {
		m, err := repo.Scan(ctx, rs)
		if err != nil {
			return nil, err
		}

		ms = append(ms, m)
	}

	if len(ms) == 0 {
		return nil, ErrTransferNotFound
	}

	return ms, nil
}

func (repo *TransferRepo) Create(ctx context.Context, m *Transfer) (*Transfer, error) {
	var (
		cols []string
		args []interface{}
	)

	cols = append(cols, repo.colID)
	args = append(args, m.ID.String())

	cols = append(cols, repo.colChainID)
	args = append(args, m.ChainID)

	cols = append(cols, repo.colBlockHash)
	args = append(args, m.BlockHash.String())

	cols = append(cols, repo.colBlockTimestamp)
	args = append(args, m.BlockTimestamp)

	if m.TransactionHash != nil {
		var transactionHash sql.NullString

		transactionHash.String = m.TransactionHash.String()
		transactionHash.Valid = true

		cols = append(cols, repo.colTransactionHash)
		args = append(args, transactionHash)
	}

	if m.MethodID != nil {
		var methodID sql.NullString

		methodID.String = *m.MethodID
		methodID.Valid = true

		cols = append(cols, repo.colMethodID)
		args = append(args, methodID)
	}

	cols = append(cols, repo.colFromAddress)
	args = append(args, m.FromAddress.String())

	var toAddress sql.NullString

	toAddress.String = m.ToAddress.String()
	toAddress.Valid = true

	cols = append(cols, repo.colToAddress)
	args = append(args, toAddress)

	cols = append(cols, repo.colAssetContract)
	args = append(args, m.AssetContract.String())

	if m.Value != nil {
		cols = append(cols, repo.colValue)
		args = append(args, m.Value.Int64())
	}

	cols = append(cols, repo.colMetadata)
	args = append(args, m.Metadata)

	cols = append(cols, repo.colTraceAddress)
	args = append(args, m.TraceAddress)

	if !m.CreatedAt.IsZero() {
		cols = append(cols, repo.colCreatedAt)
		args = append(args, m.CreatedAt)
	}

	values := make([]string, len(cols))

	for i := range cols {
		values[i] = fmt.Sprintf("$%d", i+1)
	}

	qCols := strings.Join(cols, ", ")
	qValues := strings.Join(values, ", ")

	rCols := strings.Join(repo.cols, ", ")

	sql := "INSERT INTO %s (%s) VALUES (%s) RETURNING %s"
	sql = fmt.Sprintf(sql, repo.table, qCols, qValues, rCols)

	return repo.Scan(ctx, repo.db.QueryRowContext(ctx, sql, args...))
}

func (repo *TransferRepo) Insert(ctx context.Context, ms ...*Transfer) error {
	// Build values query.
	var (
		valuesQueryBuilder strings.Builder
		lms                = len(ms)
	)

	var cols []string

	cols = append(cols, repo.colID)
	cols = append(cols, repo.colChainID)
	cols = append(cols, repo.colBlockHash)
	cols = append(cols, repo.colBlockTimestamp)
	cols = append(cols, repo.colTransactionHash)
	cols = append(cols, repo.colMethodID)
	cols = append(cols, repo.colFromAddress)
	cols = append(cols, repo.colToAddress)
	cols = append(cols, repo.colAssetContract)
	cols = append(cols, repo.colValue)
	cols = append(cols, repo.colMetadata)
	cols = append(cols, repo.colTraceAddress)
	cols = append(cols, repo.colCreatedAt)

	lcols := len(cols)

	// Size is equal to the number of models (lms) multiplied by the number of columns (lcols).
	args := make([]interface{}, 0, lms*lcols)

	for i := range ms {
		m := ms[i]

		indexOffset := i * lcols

		valuesQueryBuilder.WriteString(repo.valuesStatement(cols, indexOffset, i != lms-1))

		args = append(args, m.ID.String())

		args = append(args, m.ChainID)

		args = append(args, m.BlockHash.String())

		args = append(args, m.BlockTimestamp)

		var transactionHash sql.NullString

		if m.TransactionHash != nil {
			transactionHash.String = m.TransactionHash.String()
			transactionHash.Valid = true
		}

		args = append(args, transactionHash)

		var methodID sql.NullString

		if m.MethodID != nil {
			methodID.String = *m.MethodID
			methodID.Valid = true
		}

		args = append(args, methodID)

		args = append(args, m.FromAddress.String())

		var toAddress sql.NullString

		toAddress.String = m.ToAddress.String()
		toAddress.Valid = true

		args = append(args, toAddress)

		args = append(args, m.AssetContract.String())

		if m.Value != nil {
			args = append(args, m.Value.Int64())
		} else {
			args = append(args, nil)
		}

		args = append(args, m.Metadata)

		args = append(args, m.TraceAddress)

		if !m.CreatedAt.IsZero() {
			args = append(args, m.CreatedAt)
		} else {
			args = append(args, nil)
		}
	}

	qCols := strings.Join(cols, ", ")

	sql := "INSERT INTO %s (%s) VALUES %s"
	sql = fmt.Sprintf(sql, repo.table, qCols, valuesQueryBuilder.String())

	_, err := repo.db.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "exec context")
	}

	return nil
}

func (repo *TransferRepo) valuesStatement(cols []string, offset int, separator bool) string {
	var sep string

	if separator {
		sep = ","
	}

	values := make([]string, len(cols))
	for i := range cols {
		values[i] = fmt.Sprintf("$%d", offset+(i+1))
	}

	return fmt.Sprintf("(%s)%s", strings.Join(values, ", "), sep)
}

func (repo *TransferRepo) Update(ctx context.Context, m *Transfer, skipZeroValues bool) error {
	var (
		sets   []string
		where  []string
		args   []interface{}
		offset = 1
	)

	where = append(where, fmt.Sprintf("%s = $%d", repo.colID, offset))
	args = append(args, m.ID)

	offset++

	where = append(where, fmt.Sprintf("%s = $%d", repo.colChainID, offset))
	args = append(args, m.ChainID)

	offset++

	if skipZeroValues {
		if m.BlockHash.String() != "" {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colBlockHash, offset))
			args = append(args, m.BlockHash.String())

			offset++
		}

		if m.BlockTimestamp != 0 {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colBlockTimestamp, offset))
			args = append(args, m.BlockTimestamp)

			offset++
		}

		if m.TransactionHash != nil {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colTransactionHash, offset))
			args = append(args, m.TransactionHash.String())

			offset++
		}

		if m.MethodID != nil {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colMethodID, offset))
			args = append(args, *m.MethodID)

			offset++
		}

		if m.FromAddress.String() != "" {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colFromAddress, offset))
			args = append(args, m.FromAddress.String())

			offset++
		}

		sets = append(sets, fmt.Sprintf("%s = $%d", repo.colToAddress, offset))
		args = append(args, m.ToAddress.String())

		offset++

		if m.AssetContract.String() != "" {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colAssetContract, offset))
			args = append(args, m.AssetContract.String())

			offset++
		}

		if m.Value != nil {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colValue, offset))
			args = append(args, m.Value.Int64())

			offset++
		}

		if len(m.Metadata) > 0 {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colMetadata, offset))
			args = append(args, m.Metadata)

			offset++
		}

		if len(m.TraceAddress) > 0 {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colTraceAddress, offset))
			args = append(args, m.TraceAddress)

			offset++
		}

		if !m.CreatedAt.IsZero() {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colCreatedAt, offset))
			args = append(args, m.CreatedAt)

			offset++
		}
	} else {
		where = append(where, fmt.Sprintf("%s = $%d", repo.colBlockHash, offset))
		args = append(args, m.BlockHash)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colBlockTimestamp, offset))
		args = append(args, m.BlockTimestamp)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colTransactionHash, offset))
		args = append(args, m.TransactionHash)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colMethodID, offset))
		args = append(args, m.MethodID)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colFromAddress, offset))
		args = append(args, m.FromAddress)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colToAddress, offset))
		args = append(args, m.ToAddress)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colAssetContract, offset))
		args = append(args, m.AssetContract)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colValue, offset))
		args = append(args, m.Value)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colMetadata, offset))
		args = append(args, m.Metadata)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colTraceAddress, offset))
		args = append(args, m.TraceAddress)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colCreatedAt, offset))
		args = append(args, m.CreatedAt)

		offset++
	}

	qSets := strings.Join(sets, ", ")
	qWhere := strings.Join(where, " AND ")

	sql := "UPDATE %s SET %s WHERE %s"
	sql = fmt.Sprintf(sql, repo.table, qSets, qWhere)

	res, err := repo.db.ExecContext(ctx, sql, args...)
	if err != nil {
		return err
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected == 0 {
		return ErrTransferUpdate
	}

	return nil
}
