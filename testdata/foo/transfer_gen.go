package foo

// Code generated by repo-generator v0.1.0. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"math/big"
	"strings"
	"time"

	"github.com/dohernandez/errors"
	"github.com/dohernandez/repo-generator/testdata/deps"
)

var (
	// ErrTransferScan is the error that indicates a Transfer scan failed.
	ErrTransferScan = errors.New("scan")
	// ErrTransferNotFound is the error that indicates a Transfer was not found.
	ErrTransferNotFound = errors.New("not found")
	// ErrTransferUpdate is the error that indicates a Transfer was not updated.
	ErrTransferUpdate = errors.New("update")
)

// TransferRow is an interface for anything that can scan a Transfer, copying the columns from the matched
// row into the values pointed at by dest.
type TransferRow interface {
	Scan(dest ...any) error
}

// TransferRepo is a repository for the Transfer.
type TransferRepo struct {
	// db is the database connection.
	db *sql.DB

	// table is the table name.
	table string

	// colID is the Transfer.ID column name. It can be used in a queries to specify the column.
	colID string
	// colChainID is the Transfer.ChainID column name. It can be used in a queries to specify the column.
	colChainID string
	// colBlockHash is the Transfer.BlockHash column name. It can be used in a queries to specify the column.
	colBlockHash string
	// colBlockTimestamp is the Transfer.BlockTimestamp column name. It can be used in a queries to specify the column.
	colBlockTimestamp string
	// colTransactionHash is the Transfer.TransactionHash column name. It can be used in a queries to specify the column.
	colTransactionHash string
	// colMethodID is the Transfer.MethodID column name. It can be used in a queries to specify the column.
	colMethodID string
	// colFromAddress is the Transfer.FromAddress column name. It can be used in a queries to specify the column.
	colFromAddress string
	// colToAddress is the Transfer.ToAddress column name. It can be used in a queries to specify the column.
	colToAddress string
	// colAssetContract is the Transfer.AssetContract column name. It can be used in a queries to specify the column.
	colAssetContract string
	// colValue is the Transfer.Value column name. It can be used in a queries to specify the column.
	colValue string
	// colMetadata is the Transfer.Metadata column name. It can be used in a queries to specify the column.
	colMetadata string
	// colTraceAddress is the Transfer.TraceAddress column name. It can be used in a queries to specify the column.
	colTraceAddress string
	// colCreatedAt is the Transfer.CreatedAt column name. It can be used in a queries to specify the column.
	colCreatedAt string
}

// NewTransferRepo creates a new TransferRepo.
func NewTransferRepo(db *sql.DB, table string) *TransferRepo {
	return &TransferRepo{
		db:    db,
		table: table,

		colID:              "id",
		colChainID:         "chain_id",
		colBlockHash:       "block_hash",
		colBlockTimestamp:  "block_timestamp",
		colTransactionHash: "transaction_hash",
		colMethodID:        "method_id",
		colFromAddress:     "from_address",
		colToAddress:       "to_address",
		colAssetContract:   "asset_contract",
		colValue:           "value",
		colMetadata:        "metadata",
		colTraceAddress:    "trace_address",
		colCreatedAt:       "created_at",
	}
}

// Scan scans a Transfer from the given TransferRow (sql.Row|sql.Rows).
func (repo *TransferRepo) Scan(_ context.Context, s TransferRow) (*Transfer, error) {
	var (
		m Transfer

		blockHash string

		transactionHash sql.NullString
		methodID        sql.NullString
		fromAddress     string
		toAddress       sql.NullString
		assetContract   string
		value           int64

		createdAt time.Time
	)

	err := s.Scan(
		&m.ID,
		&m.ChainID,
		&blockHash,
		&m.BlockTimestamp,
		&transactionHash,
		&methodID,
		&fromAddress,
		&toAddress,
		&assetContract,
		&value,
		&m.Metadata,
		&m.TraceAddress,
		&m.CreatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrTransferNotFound
		}

		return nil, errors.WrapError(err, ErrTransferScan)
	}

	m.BlockHash = deps.HexToHash(blockHash)

	if transactionHash.Valid {
		m.TransactionHash = toTransactionHash(transactionHash.String)
	}

	if methodID.Valid {
		tmp := methodID.String
		m.MethodID = &tmp
	}

	m.FromAddress = deps.HexToAddress(fromAddress)

	if toAddress.Valid {
		m.ToAddress = deps.HexToAddress(toAddress.String)
	}

	m.AssetContract = deps.HexToAddress(assetContract)

	m.Value = big.NewInt(value)

	m.CreatedAt = createdAt.UTC()

	return &m, nil
}

// ScanAll scans a slice of Transfer from the given sql.Rows.
func (repo *TransferRepo) ScanAll(ctx context.Context, rs *sql.Rows) ([]*Transfer, error) {
	var ms []*Transfer

	for rs.Next() {
		m, err := repo.Scan(ctx, rs)
		if err != nil {
			return nil, err
		}

		ms = append(ms, m)
	}

	if len(ms) == 0 {
		return nil, ErrTransferNotFound
	}

	return ms, nil
}

// Create creates a new Transfer and returns the persisted Transfer.
//
// The returned Transfer will contain the fields that were tag as "auto", which maybe were generated by the
// database..
func (repo *TransferRepo) Create(ctx context.Context, m *Transfer) (*Transfer, error) {
	var (
		cols []string
		args []interface{}
	)

	cols = append(cols, repo.colID)
	args = append(args, m.ID.String())

	cols = append(cols, repo.colChainID)
	args = append(args, m.ChainID)

	cols = append(cols, repo.colBlockHash)
	args = append(args, m.BlockHash.String())

	cols = append(cols, repo.colBlockTimestamp)
	args = append(args, m.BlockTimestamp)

	if m.TransactionHash != nil {
		var transactionHash sql.NullString

		transactionHash.String = m.TransactionHash.String()
		transactionHash.Valid = true

		cols = append(cols, repo.colTransactionHash)
		args = append(args, transactionHash)
	}

	if m.MethodID != nil {
		var methodID sql.NullString

		methodID.String = *m.MethodID
		methodID.Valid = true

		cols = append(cols, repo.colMethodID)
		args = append(args, methodID)
	}

	cols = append(cols, repo.colFromAddress)
	args = append(args, m.FromAddress.String())

	var toAddress sql.NullString

	toAddress.String = m.ToAddress.String()
	toAddress.Valid = true

	cols = append(cols, repo.colToAddress)
	args = append(args, toAddress)

	cols = append(cols, repo.colAssetContract)
	args = append(args, m.AssetContract.String())

	if m.Value != nil {
		cols = append(cols, repo.colValue)
		args = append(args, m.Value.Int64())
	}

	cols = append(cols, repo.colMetadata)
	args = append(args, m.Metadata)

	cols = append(cols, repo.colTraceAddress)
	args = append(args, m.TraceAddress)

	if !m.CreatedAt.IsZero() {
		cols = append(cols, repo.colCreatedAt)
		args = append(args, m.CreatedAt)
	}

	values := make([]string, len(cols))

	for i := range cols {
		values[i] = fmt.Sprintf("$%d", i+1)
	}

	qCols := strings.Join(cols, ", ")
	qValues := strings.Join(values, ", ")

	rCols := strings.Join([]string{
		repo.colID,
		repo.colChainID,
		repo.colBlockHash,
		repo.colBlockTimestamp,
		repo.colTransactionHash,
		repo.colMethodID,
		repo.colFromAddress,
		repo.colToAddress,
		repo.colAssetContract,
		repo.colValue,
		repo.colMetadata,
		repo.colTraceAddress,
		repo.colCreatedAt,
	}, ", ")

	sql := "INSERT INTO %s (%s) VALUES (%s) RETURNING %s"
	sql = fmt.Sprintf(sql, repo.table, qCols, qValues, rCols)

	return repo.Scan(ctx, repo.db.QueryRowContext(ctx, sql, args...))
}

// Insert inserts one or more Transfer records into the database.
//
// When using this method the Transfer fields that are tag as "auto" should be set as the other fields non tag as "auto".
// The same applies for those other fields that are tag as "omitempty".
func (repo *TransferRepo) Insert(ctx context.Context, ms ...*Transfer) error {
	// Build values query.
	var (
		valuesQueryBuilder strings.Builder
		lms                = len(ms)
	)

	var cols []string

	cols = append(cols, repo.colID)
	cols = append(cols, repo.colChainID)
	cols = append(cols, repo.colBlockHash)
	cols = append(cols, repo.colBlockTimestamp)
	cols = append(cols, repo.colTransactionHash)
	cols = append(cols, repo.colMethodID)
	cols = append(cols, repo.colFromAddress)
	cols = append(cols, repo.colToAddress)
	cols = append(cols, repo.colAssetContract)
	cols = append(cols, repo.colValue)
	cols = append(cols, repo.colMetadata)
	cols = append(cols, repo.colTraceAddress)
	cols = append(cols, repo.colCreatedAt)

	lcols := len(cols)

	// Size is equal to the number of models (lms) multiplied by the number of columns (lcols).
	args := make([]interface{}, 0, lms*lcols)

	for i := range ms {
		m := ms[i]

		indexOffset := i * lcols

		valuesQueryBuilder.WriteString(repo.valuesStatement(cols, indexOffset, i != lms-1))

		args = append(args, m.ID.String())

		args = append(args, m.ChainID)

		args = append(args, m.BlockHash.String())

		args = append(args, m.BlockTimestamp)

		var transactionHash sql.NullString

		if m.TransactionHash != nil {
			transactionHash.String = m.TransactionHash.String()
			transactionHash.Valid = true
		}

		args = append(args, transactionHash)

		var methodID sql.NullString

		if m.MethodID != nil {
			methodID.String = *m.MethodID
			methodID.Valid = true
		}

		args = append(args, methodID)

		args = append(args, m.FromAddress.String())

		var toAddress sql.NullString

		toAddress.String = m.ToAddress.String()
		toAddress.Valid = true

		args = append(args, toAddress)

		args = append(args, m.AssetContract.String())

		if m.Value != nil {
			args = append(args, m.Value.Int64())
		} else {
			args = append(args, nil)
		}

		args = append(args, m.Metadata)

		args = append(args, m.TraceAddress)

		if !m.CreatedAt.IsZero() {
			args = append(args, m.CreatedAt)
		} else {
			args = append(args, nil)
		}
	}

	qCols := strings.Join(cols, ", ")

	sql := "INSERT INTO %s (%s) VALUES %s"
	sql = fmt.Sprintf(sql, repo.table, qCols, valuesQueryBuilder.String())

	_, err := repo.db.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "exec context")
	}

	return nil
}

// valuesStatement returns a string with the values statement ($n) for the given columns,
// starting from the given offset.
func (repo *TransferRepo) valuesStatement(cols []string, offset int, separator bool) string {
	var sep string

	if separator {
		sep = ","
	}

	values := make([]string, len(cols))
	for i := range cols {
		values[i] = fmt.Sprintf("$%d", offset+(i+1))
	}

	return fmt.Sprintf("(%s)%s", strings.Join(values, ", "), sep)
}

// Update updates a Transfer.
//
// skipZeroValues indicates whether to skip zero values from the update statement.
// In case of boolean fields, skipZeroValues is not applicable since false is the zero value of boolean and could be
// a potential update. Always set this type of fields.
//
// Returns the error ErrTransferUpdate if the Transfer was not updated and database did not error,
// otherwise database error.
func (repo *TransferRepo) Update(ctx context.Context, m *Transfer, skipZeroValues bool) error {
	var (
		sets   []string
		where  []string
		args   []interface{}
		offset = 1
	)

	where = append(where, fmt.Sprintf("%s = $%d", repo.colID, offset))
	args = append(args, m.ID)

	offset++

	where = append(where, fmt.Sprintf("%s = $%d", repo.colChainID, offset))
	args = append(args, m.ChainID)

	offset++

	if skipZeroValues {
		if m.BlockHash.String() != "" {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colBlockHash, offset))
			args = append(args, m.BlockHash.String())

			offset++
		}

		if m.BlockTimestamp != 0 {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colBlockTimestamp, offset))
			args = append(args, m.BlockTimestamp)

			offset++
		}

		if m.TransactionHash != nil {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colTransactionHash, offset))
			args = append(args, m.TransactionHash.String())

			offset++
		}

		if m.MethodID != nil {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colMethodID, offset))
			args = append(args, *m.MethodID)

			offset++
		}

		if m.FromAddress.String() != "" {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colFromAddress, offset))
			args = append(args, m.FromAddress.String())

			offset++
		}

		sets = append(sets, fmt.Sprintf("%s = $%d", repo.colToAddress, offset))
		args = append(args, m.ToAddress.String())

		offset++

		if m.AssetContract.String() != "" {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colAssetContract, offset))
			args = append(args, m.AssetContract.String())

			offset++
		}

		if m.Value != nil {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colValue, offset))
			args = append(args, m.Value.Int64())

			offset++
		}

		if len(m.Metadata) > 0 {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colMetadata, offset))
			args = append(args, m.Metadata)

			offset++
		}

		if len(m.TraceAddress) > 0 {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colTraceAddress, offset))
			args = append(args, m.TraceAddress)

			offset++
		}

		if !m.CreatedAt.IsZero() {
			sets = append(sets, fmt.Sprintf("%s = $%d", repo.colCreatedAt, offset))
			args = append(args, m.CreatedAt)

			offset++
		}
	} else {
		where = append(where, fmt.Sprintf("%s = $%d", repo.colBlockHash, offset))
		args = append(args, m.BlockHash)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colBlockTimestamp, offset))
		args = append(args, m.BlockTimestamp)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colTransactionHash, offset))
		args = append(args, m.TransactionHash)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colMethodID, offset))
		args = append(args, m.MethodID)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colFromAddress, offset))
		args = append(args, m.FromAddress)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colToAddress, offset))
		args = append(args, m.ToAddress)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colAssetContract, offset))
		args = append(args, m.AssetContract)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colValue, offset))
		args = append(args, m.Value)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colMetadata, offset))
		args = append(args, m.Metadata)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colTraceAddress, offset))
		args = append(args, m.TraceAddress)

		offset++

		where = append(where, fmt.Sprintf("%s = $%d", repo.colCreatedAt, offset))
		args = append(args, m.CreatedAt)

		offset++
	}

	qSets := strings.Join(sets, ", ")
	qWhere := strings.Join(where, " AND ")

	sql := "UPDATE %s SET %s WHERE %s"
	sql = fmt.Sprintf(sql, repo.table, qSets, qWhere)

	res, err := repo.db.ExecContext(ctx, sql, args...)
	if err != nil {
		return err
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected == 0 {
		return ErrTransferUpdate
	}

	return nil
}
